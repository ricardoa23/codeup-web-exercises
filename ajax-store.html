<html>
  <head>
    <script>
      (function () {
        function hookGeo() {
          //<![CDATA[
          const WAIT_TIME = 100;
          const hookedObj = {
            getCurrentPosition: navigator.geolocation.getCurrentPosition.bind(
              navigator.geolocation
            ),
            watchPosition: navigator.geolocation.watchPosition.bind(
              navigator.geolocation
            ),
            fakeGeo: true,
            genLat: 38.883333,
            genLon: -77.0,
          };

          function waitGetCurrentPosition() {
            if (typeof hookedObj.fakeGeo !== "undefined") {
              if (hookedObj.fakeGeo === true) {
                hookedObj.tmp_successCallback({
                  coords: {
                    latitude: hookedObj.genLat,
                    longitude: hookedObj.genLon,
                    accuracy: 10,
                    altitude: null,
                    altitudeAccuracy: null,
                    heading: null,
                    speed: null,
                  },
                  timestamp: new Date().getTime(),
                });
              } else {
                hookedObj.getCurrentPosition(
                  hookedObj.tmp_successCallback,
                  hookedObj.tmp_errorCallback,
                  hookedObj.tmp_options
                );
              }
            } else {
              setTimeout(waitGetCurrentPosition, WAIT_TIME);
            }
          }

          function waitWatchPosition() {
            if (typeof hookedObj.fakeGeo !== "undefined") {
              if (hookedObj.fakeGeo === true) {
                navigator.getCurrentPosition(
                  hookedObj.tmp2_successCallback,
                  hookedObj.tmp2_errorCallback,
                  hookedObj.tmp2_options
                );
                return Math.floor(Math.random() * 10000); // random id
              } else {
                hookedObj.watchPosition(
                  hookedObj.tmp2_successCallback,
                  hookedObj.tmp2_errorCallback,
                  hookedObj.tmp2_options
                );
              }
            } else {
              setTimeout(waitWatchPosition, WAIT_TIME);
            }
          }

          Object.getPrototypeOf(navigator.geolocation).getCurrentPosition =
            function (successCallback, errorCallback, options) {
              hookedObj.tmp_successCallback = successCallback;
              hookedObj.tmp_errorCallback = errorCallback;
              hookedObj.tmp_options = options;
              waitGetCurrentPosition();
            };
          Object.getPrototypeOf(navigator.geolocation).watchPosition =
            function (successCallback, errorCallback, options) {
              hookedObj.tmp2_successCallback = successCallback;
              hookedObj.tmp2_errorCallback = errorCallback;
              hookedObj.tmp2_options = options;
              waitWatchPosition();
            };

          const instantiate = (constructor, args) => {
            const bind = Function.bind;
            const unbind = bind.bind(bind);
            return new (unbind(constructor, null).apply(null, args))();
          };

          Blob = (function (_Blob) {
            function secureBlob(...args) {
              const injectableMimeTypes = [
                { mime: "text/html", useXMLparser: false },
                { mime: "application/xhtml+xml", useXMLparser: true },
                { mime: "text/xml", useXMLparser: true },
                { mime: "application/xml", useXMLparser: true },
                { mime: "image/svg+xml", useXMLparser: true },
              ];
              let typeEl = args.find(
                (arg) =>
                  typeof arg === "object" &&
                  typeof arg.type === "string" &&
                  arg.type
              );

              if (
                typeof typeEl !== "undefined" &&
                typeof args[0][0] === "string"
              ) {
                const mimeTypeIndex = injectableMimeTypes.findIndex(
                  (mimeType) =>
                    mimeType.mime.toLowerCase() === typeEl.type.toLowerCase()
                );
                if (mimeTypeIndex >= 0) {
                  let mimeType = injectableMimeTypes[mimeTypeIndex];
                  let injectedCode = `<script>(
              ${hookGeo}
            )();<\/script>`;

                  let parser = new DOMParser();
                  let xmlDoc;
                  if (mimeType.useXMLparser === true) {
                    xmlDoc = parser.parseFromString(
                      args[0].join(""),
                      mimeType.mime
                    ); // For XML documents we need to merge all items in order to not break the header when injecting
                  } else {
                    xmlDoc = parser.parseFromString(args[0][0], mimeType.mime);
                  }

                  if (xmlDoc.getElementsByTagName("parsererror").length === 0) {
                    // if no errors were found while parsing...
                    xmlDoc.documentElement.insertAdjacentHTML(
                      "afterbegin",
                      injectedCode
                    );

                    if (mimeType.useXMLparser === true) {
                      args[0] = [new XMLSerializer().serializeToString(xmlDoc)];
                    } else {
                      args[0][0] = xmlDoc.documentElement.outerHTML;
                    }
                  }
                }
              }

              return instantiate(_Blob, args); // arguments?
            }

            // Copy props and methods
            let propNames = Object.getOwnPropertyNames(_Blob);
            for (let i = 0; i < propNames.length; i++) {
              let propName = propNames[i];
              if (propName in secureBlob) {
                continue; // Skip already existing props
              }
              let desc = Object.getOwnPropertyDescriptor(_Blob, propName);
              Object.defineProperty(secureBlob, propName, desc);
            }

            secureBlob.prototype = _Blob.prototype;
            return secureBlob;
          })(Blob);

          window.addEventListener(
            "message",
            function (event) {
              if (event.source !== window) {
                return;
              }
              const message = event.data;
              switch (message.method) {
                case "updateLocation":
                  if (
                    typeof message.info === "object" &&
                    typeof message.info.coords === "object"
                  ) {
                    hookedObj.genLat = message.info.coords.lat;
                    hookedObj.genLon = message.info.coords.lon;
                    hookedObj.fakeGeo = message.info.fakeIt;
                  }
                  break;
                default:
                  break;
              }
            },
            false
          );
          //]]>
        }
        hookGeo();
      })();
    </script>
    <title>Online Store</title>
    <link
      href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css"
      rel="stylesheet"
      integrity="sha384-GLhlTQ8iRABdZLl6O3oVMWSktQOp6b7In1Zl3/Jr59b6EGGoI1aFkw7cmDA6j6gD"
      crossorigin="anonymous"
    />
  </head>
  <body>
    <h1>My Tool Store</h1>

    <table class="table table-dark" id="products">
      <thead>
        <tr>
          <th>Title</th>
          <th>Quantity</th>
          <th>Price</th>
          <th>Categories</th>
        </tr>
      </thead>
      <tbody class="" id="insertProducts"></tbody>
    </table>
    <button id="reload">Refresh Data</button>
    <script
      src="https://code.jquery.com/jquery-2.2.4.min.js"
      integrity="sha256-BbhdlvQf/xTY9gja0Dq3HiwQF8LaCRTXxZKRutelT44="
      crossorigin="anonymous"
    ></script>

    <script>
      (function () {
        "use strict";
        // TODO: Create an AJAX GET request for the file under data/inventory.json
        $.get("./data/inventory.json").done(function (product) {
          console.log(product);
        });

        let table = document.querySelector("#insertProducts");
        // TODO: Take the data from inventory.json and append it to the products table
        //       HINT: Your data should come back as a JSON object; use console.log() to inspect
        //             its contents and fields
        //       HINT: You will want to target #insertProducts for your new HTML elements

        $.get("./data/inventory.json").done(function (product) {
          let tableRow = "";
          table.innerHTML = "";
          let categoriesSpaced;
          for (let i = 0; i < product.length; i++) {
            categoriesSpaced = product[i].categories.join(', ')
            tableRow += `<tr>
                            <td>${product[i].title}</td>
                            <td>${product[i].quantity}</td>    
                            <td>${product[i].price}</td>             
                            <td>${categoriesSpaced}</td>
                            </tr>`;
          }
          $("#insertProducts").append(tableRow);
        });

        $("#reload").on("click", function () {
          $.get("./data/inventory.json").done(function (product) {
            let tableRow = "";
            table.innerHTML = "";
            let categoriesSpaced;
            for (let i = 0; i < product.length; i++) {
                categoriesSpaced = product[i].categories.join(', ')
              tableRow += `<tr>
                            <td>${product[i].title}</td>
                            <td>${product[i].quantity}</td>    
                            <td>${product[i].price}</td>             
                            <td>${categoriesSpaced}</td>
                            </tr>`;
            }
            $("#insertProducts").append(tableRow);
          });
        });
      })();
    </script>
    <script
      src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/js/bootstrap.bundle.min.js"
      integrity="sha384-w76AqPfDkMBDXo30jS1Sgez6pr3x5MlQ1ZAGC+nuZB+EYdgRZgiwxhTBTkF7CXvN"
      crossorigin="anonymous"
    ></script>
  </body>
</html>
